#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}
;; TODO divmod
( int, int, int, int ) setbitmask((int,int,int,int) value,int pos) inline {
    (int a,int b,int c, int d) = value;
    (var number,pos) = divmod(pos , 256);
    var bit = 1 << pos;
    ;; var pos = pos % 256;
    if number == 0 {
        d = d | bit;
    } else
    {
        if number == 1 {
            c = c | bit;
        } else {
            if number == 2 {
                b = b | bit;
            } else {
                a = a | bit;
            }
        }
    }
    return (a,b,c,d);
}

;; TODO divmod
int getbitmask((int,int,int,int) value,int pos) inline {
    (int a,int b,int c, int d) = value;
    (var number, pos) = divmod(pos,256);
    return (((number == 0) ? d : (number == 1) ? c : ( number == 2 ) ? b : a ) >> pos) & 1;
}




(int) tlen (tuple t) asm "TLEN";

(int,int) look_start(int n,int m,tuple maze) inline {
    var i = 0;
    repeat (n) {
        var str = at(maze, i);  ;;.begin_parse();
        var j = 0;
        repeat (m) {
            var item = at(str, j);
            if (item == "S"u) {
                return (i, j);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return (0 , 0);
}

;; Tuple of slice's
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    ;; return (-1,0,0, null());
    ;;        () solve() method_id {
    ;;            var n = 3;
    ;;            var m = 3;
    ;;            tuple maze = empty_tuple();
    ;;            tuple maze2 = empty_tuple();
    ;;            maze2~tpush("S"u);
    ;;            maze2~tpush("."u);
    ;;            maze2~tpush("."u);
    ;;            maze~tpush(maze2);
    ;;            tuple maze2 = empty_tuple();
    ;;            maze2~tpush("?"u);
    ;;            maze2~tpush("X"u);
    ;;            maze2~tpush("X"u);
    ;;            maze~tpush(maze2);
    ;;            tuple maze2 = empty_tuple();
    ;;           maze2~tpush("."u);
    ;;            maze2~tpush("."u);
    ;;            maze2~tpush("E"u);
    ;;            maze~tpush(maze2);
    ;;            maze~tpush("S..");
    ;;            maze~tpush(".??");
    ;;            maze~tpush("..E");
    var i = 0;
    (int startx,int starty) = look_start(n,m,maze);


    var state = new_dict();

    ;; var finished = 0;
    var current = cons ([ startx , starty , 0 , null() ], null());
    var answer = null();
    var countBest = 2000000;
    ;; current~dump();
    while (  ~ null? (current) ) {
        var next = null();
        while (~ null?(current)) {
            (var curpos, current) = uncons(current);

            [int _x, _ , _ , _ ] = curpos;
            var dx = ( _x == 0 ) ? 0 : -1 ;

            do {
                var dy = -1;
                repeat(3) {
                    if (dx | dy) {
                        ;;  (next, answer, state) = update(curpos, state, maze, dx, dy, n, m, next, answer, end);
                        [int x,int y,int count,tuple path] = curpos;
                        x = x + dx;
                        y = y + dy;
                        if (~ ((x < 0) | (y < 0) | (x >= n) | ( y >= m))) {
                            var sym = at(at(maze, x), y);
                            if (sym != "S"u) {
                                if (sym == "X"u) {
                                    count = count + 1024;
                                }
                                else {
                                    if (sym == "?"u) {
                                        count = count + 1;
                                    }
                                }
                                var index = (x << 5) + y;
                                (var state_cell, int f) = state.udict_get?(10, index);
                                var test = true;
                                if (f) {
                                    if (state_cell.preload_int(20) <= count) {
                                        test = false;
                                    }
                                }
                                if (test) {

                                    state = state.udict_set_builder(10, index, begin_cell().store_uint(count, 20));
                                    if (sym != "E"u) {
                                        path = cons([x, y], path);
                                        next = cons( [x, y,count,path],next);
                                    } else {
                                        if ( count < countBest ) {
                                            answer = path;
                                            countBest = count;
                                        }
                                    }
                                }
                            }
                        }

                    }

                    dy = dy + 1;
                }

                dx = dx + 1;
            } until (dx > 1);
        }
        current = next;
    }


    if (countBest == 2000000) {
        ;;          return ();
        return (-1,0,0, null());
    }
    var path = answer;
    var prob = countBest;

    var res_dict = (0,0,0,0);
    var distance = 0;
    while (~ null?(path)) {
        (var coords, path) = path.uncons();
        [int x,int y] = coords;
        distance = distance + 1;
        res_dict = setbitmask(res_dict,x * m + y);
    }

    tuple maze2 = empty_tuple();
    var i = 0;
    do {
        var str = at(maze, i);
        var j = 0;
        var str_gen = empty_tuple();
        do {
            var item = at(str,j);
            if (getbitmask(res_dict, i * m + j)) {
                str_gen~tpush("!"u);
            } else {
                str_gen~tpush(item);
            }
            j = j + 1;
        } until (j == m);
        i  = i + 1;
        maze2~tpush(str_gen);
    } until (i == n);
    var res =  (prob / 1024,prob % 1024, distance + 1 , maze2);
    ;;      prob~dump();
    ;;      distance~dump();
    ;;       maze2~dump();
    return res;
    ;;      return ();
}
