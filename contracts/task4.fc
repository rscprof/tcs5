#include "imports/stdlib.fc";


forall X -> tuple create_tuple(X value, int n) asm  """
DUP
1 SETGLOB
DEC
REPEAT:<{ DUP }>
1 GETGLOB
TUPLEVAR
""";

forall X -> X get_value(tuple t,int i, int j) inline {
    return at(at(t,i),j);
}

forall X -> tuple set_index_var (tuple t,X value,int pos) asm "SETINDEXVAR";

forall X -> tuple set_value(tuple t,int i,int j, X value) inline  {
    tuple t2 = at(t,i);
    t2 = set_index_var(t2,value,j);
    return set_index_var(t,t2,i);
}


() recv_internal(slice in_msg_body) impure {
}




(int,int) look_start(int n,int m,tuple maze) inline {
    var i = 0;
    repeat (n) {
        var str = at(maze, i);  ;;.begin_parse();
        var j = 0;
        repeat (m) {
            var item = at(str, j);
            if (item == "S"u) {
                return (i, j);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return (0 , 0);
}

;; Tuple of slice's
 (int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    ;; return (-1,0,0, null());
;;            () solve() method_id {
;;                var n = 3;
;;                var m = 3;
;;                tuple maze = empty_tuple();
;;                tuple maze2 = empty_tuple();
;;                maze2~tpush("S"u);
;;                maze2~tpush("."u);
;;                maze2~tpush("."u);
;;                maze~tpush(maze2);
;;                tuple maze2 = empty_tuple();
;;                maze2~tpush("?"u);
;;                maze2~tpush("X"u);
;;                maze2~tpush("X"u);
;;                maze~tpush(maze2);
;;                tuple maze2 = empty_tuple();
;;               maze2~tpush("."u);
;;                maze2~tpush("."u);
;;                maze2~tpush("E"u);
;;                maze~tpush(maze2);
;;                maze~tpush("S..");
;;                maze~tpush(".??");
;;                maze~tpush("..E");
    (int startx,int starty) = look_start(n,m,maze);


   ;; var state = new_dict();
    tuple state1 = create_tuple(1024 * 1024,m);
    tuple state = create_tuple(state1,n);

  ;;  state = state.udict_set_builder(10, startx << 5 + starty, begin_cell().store_uint(0, 20));
    state = set_value(state,startx,starty,0);

    ;; var finished = 0;
    var current = cons ([ startx , starty , 0 , null() ], null());
    var answer = null();
    var countBest = 2000000;
    ;; current~dump();
    do {
        var next = null();
        do {
            (var curpos, current) = uncons(current);

            [int _x, _ , _ , _ ] = curpos;
            var dx = ( _x ) ? -1 : 0 ;

            do {
                var x = _x + dx;
                if ( x < n) {
                    var str = at(maze, x);
                    var dy = -1;
                    repeat (3) {
                        if (dx | dy) {
                            [int x, int y, int count, tuple path] = curpos;
                            x = x + dx;
                            y = y + dy;
                            if (((y >= 0) & (y < m))) {
                                var sym = at(str, y);

                                        if (sym == "X"u) {
                                            count = count + 1000;
                                        }
                                        else {
                                            if (sym == "?"u) {
                                                count = count + 1;
                                            }
                                        }
                                        if (count < countBest) {
                                            if (get_value(state,x,y) > count) {
                                                state = set_value(state,x,y,count);
                                                if (sym == "E"u) {
                                                        answer = path;
                                                        countBest = count;
                                                } else {
                                                    path = cons([x , y], path);
                                                    next = cons([x, y, count, path], next);
                                                }
                                            }
                                        }
                                    }

                        }

                        dy = dy + 1;
                    }
                }

                dx = dx + 1;
            } until (dx > 1);
        } until ( null?(current));
        current = next;
    } until (  null? (current) );


    if (countBest == 2000000) {
         return (-1,0,0, null());
    }
    var path = answer;
    var prob = countBest;

    var distance = 1;
    while (~ null?(path)) {
        (var res, path) = path.uncons();
        [int x,int y] = res;
    ;;    (int x,int y) = divmod(index,32);
        distance = distance + 1;
        var str = at(maze, x);
        str = set_index_var(str,"!"u,y);
        maze = set_index_var(maze,str,x);
    }

    (int d,int m) = divmod(prob,1000);
    return  (d,m, distance  , maze);
}
