#include "imports/stdlib.fc";
;; 5397
;; 5862

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}
;; TODO divmod
( int, int, int, int ) setbitmask((int,int,int,int) value,int pos) inline {
    (int a,int b,int c, int d) = value;
    (var number,pos) = divmod(pos , 256);
    ;; var pos = pos % 256;
    if number == 0 {
        d = d | (1 << pos);
    } else
    {
        if number == 1 {
            c = c | (1 << pos);
        } else {
            if number == 2 {
                b = b | (1 << pos);
            } else {
                a = a | (1 << pos);
            }
        }
    }
    return (a,b,c,d);
}

;; TODO divmod
int getbitmask((int,int,int,int) value,int pos) inline {
    (int a,int b,int c, int d) = value;
    (var number, pos) = divmod(pos,256);
    ;; var number = pos / 256;
    ;; var pos = pos % 256;
    if number == 0 {
        return (d >> pos) & 1;
    } else
    {
        if number == 1 {
            return (c >> pos) & 1;
        } else {
            if number == 2 {
                return (b >> pos) & 1;
            } else {
                return (a >> pos) & 1;
            }
        }
    }
}


(tuple, [(int,int),int,tuple],cell) update(
    [(int,int),int,tuple] curpos,cell state,tuple maze,int dx,int dy,int n,int m, ;;from test
    tuple next, [(int,int),int,tuple] answer, (int,int) end) inline ;;from update
{
    [(int x,int y),int count,tuple path] = curpos;
  ;;  var newpos = null();
  ;;  var flag = 0;
 ;;   var default = (null(),state,0);
 ;;   (var newpos, var state, var flag) = default;
    x = x + dx;
    y = y + dy;
    if (~ ((x < 0) | (y < 0) | (x >= n) | ( y >= m))) {
        var sym = at(at(maze, x), y);
        if (sym != "S"u) {

            if (sym == "X"u) {
                count = count + 1024;
            }
            else {
                if (sym == "?"u) {
                    count = count + 1;
                }
            }
            var index = (x << 5) + y;
            (var state_cell, int f) = state.udict_get?(10, index);
            var test = true;
            if (f) {
                if (state_cell.preload_int(20) <= count) {
                    test = false;
                }
            }
            if (test) {
                state = state.udict_set_builder(10, index, begin_cell().store_uint(count, 20));
                var newpos = [(x, y),count,path];
                if (sym != "E"u) {
                    path = cons([x, y], path);
                    next = cons( newpos,next);
                } else {
                    var countBest = 2000000;
                    if ~ null?(answer) {
                        [_, countBest, _] = answer;
                    }
                    if ( count < countBest ) {
                        answer = newpos;
                    }
                }
       ;;         newpos = [(x, y),count,path];
    ;;            flag = true;
              ;;  default = ([newpos, count, path], state, -1);
               ;; (newpos, state, flag) = default;
            }
        }
    }
;;    (var newpos, var state, var flag) = default;


;;    if (flag) {
;;        ;;var f = first(newpos);
;;     ;;   [var f,var count,_] = newpos;
;;     ;;   (var x, var y) = f;
;;    ;;    (var endx, var endy) = end;
;;
;;        if ((x == endx) & (y == endy)) {
;;            if (null? (answer) | ( count < countBest )) {
;;                answer = newpos;
;;            }
;;        } else {
;;            next = cons( newpos,next);
;;        }
;;    }

    ;;   next~dump();
    return (next, answer,state);
}

;; (start,0,())
;;([(int,int),int,tuple],cell,int) test ([(int,int),int,tuple] curpos,cell state,tuple maze,int dx,int dy,int n,int m) inline
;;{
;;    ;;  curpos~dump();
;;
;;    [(int x,int y),int count,tuple path] = curpos;
;;    var default = (null(),state,0);
;;    ;;    var pos = first(curpos);
;;    ;;    var count = second(curpos);
;;    ;;    var path = third(curpos);
;;    ;;    ;;    var count, var path) = curpos;
;;    ;; (var x, var y) = pos;
;;    x = x + dx;
;;    y = y + dy;
;;    ;;  x~dump();
;;    ;;  y~dump();
;;    if (~ ((x < 0) | (y < 0) | (x >= n) | ( y >= m))) {
;;        var sym = at(at(maze, x), y);
;;        if (sym != "S"u) {
;;
;;            if (sym == "X"u) {
;;                count = count + 1024;
;;            }
;;            else {
;;                if (sym == "?"u) {
;;                    count = count + 1;
;;                }
;;            }
;;            var index = (x << 5) + y;
;;            (var state_cell, int f) = state.udict_get?(10, index);
;;            var test = true;
;;            if (f) {
;;                if (state_cell.preload_int(20) <= count) {
;;                    test = false;
;;                }
;;            }
;;            if (test) {
;;                state = state.udict_set_builder(10, index, begin_cell().store_uint(count, 20));
;;                ;;  state~dump();
;;                ;;   x~dump();
;;                ;;   y~dump();
;;                ;;   count~dump();
;;                var newpos = (x, y);
;;                if (sym != "E"u) {
;;                    path = cons([x, y], path);
;;                }
;;                default = ([newpos, count, path], state, -1);
;;            }
;;        }
;;    }
;;    return default;
;;}


(int) tlen (tuple t) asm "TLEN";

;; Tuple of slice's
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    ;; return (-1,0,0, null());
;;        () solve() method_id {
;;            var n = 3;
;;            var m = 3;
;;            tuple maze = empty_tuple();
;;            tuple maze2 = empty_tuple();
;;            maze2~tpush("S"u);
;;            maze2~tpush("."u);
;;            maze2~tpush("."u);
;;            maze~tpush(maze2);
;;            tuple maze2 = empty_tuple();
;;            maze2~tpush("?"u);
;;            maze2~tpush("X"u);
;;            maze2~tpush("X"u);
;;            maze~tpush(maze2);
;;            tuple maze2 = empty_tuple();
;;           maze2~tpush("."u);
;;            maze2~tpush("."u);
;;            maze2~tpush("E"u);
;;            maze~tpush(maze2);
;;            maze~tpush("S..");
;;            maze~tpush(".??");
;;            maze~tpush("..E");
    var i = 0;
    var start = (0,0);
    var end = (0,0);
    repeat(n) {
        var str = at(maze,i);  ;;.begin_parse();
        var j = 0;

        repeat(m) {

            var item = at(str,j);
            ;;var item = sl.begin_parse().preload_uint(8);
            ;; maze.tpush(str);
            ;;    var item = at(str,j);
            if (item == "S"u) {
                start = (i , j);
            }
            if (item == "E"u) {
                end = (i , j);
            }
            j = j + 1;
        }
        i  = i + 1;
    }

    var state = new_dict();

    ;; var finished = 0;
    var current = cons ([start,0,null()], null());
    var answer = null();
    ;; current~dump();
    while (  ~ null? (current) ) {
        var next = null();
        while (~ null?(current)) {
            (var curpos, current) = uncons(current);

            var dx = -1;
            do {
                var dy = -1;
                do {
                    if (dx | dy) {
                        (next, answer, state) = update(curpos, state, maze, dx, dy, n, m, next, answer, end);

                    }

                    dy = dy + 1;
                } until (dy > 1);

                dx = dx + 1;
            } until (dx > 1);
;;            (next, answer, state) = update(curpos, state, maze, -1, -1, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, -1, 0, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, -1, 1, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, 0, -1, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, 0, 1, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, 1, -1, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, 1, 0, n, m, next, answer, end);
;;            (next, answer, state) = update(curpos, state, maze, 1, 1, n, m, next, answer, end);
;;
;;            (newpos, state, flag) = test (curpos, state, maze, -1, 0, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            (newpos, state, flag) = test (curpos, state, maze, -1, 1, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            ;;   next~dump();
;;            (newpos, state, flag) = test (curpos, state, maze, 0, -1, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            (newpos, state, flag) = test (curpos, state, maze, 0, 1, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            (newpos, state, flag) = test (curpos, state, maze, 1, -1, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            (newpos, state, flag) = test (curpos, state, maze, 1, 0, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
;;            (newpos, state, flag) = test (curpos, state, maze, 1, 1, n, m);
;;            (next, answer) = update(next, answer, newpos, end, flag);
        }
        ;;   if null? (next) {
        ;;       finished = true;
        ;;   }
        current = next;
    }


    if (null?(answer)) {
;;          return ();
        return (-1,0,0, null());
    }
    ;;  answer~dump();
    ;; [(int,int),int,tuple] answer
    [_,var prob,var path] = answer;
    ;;    var numProb = 100;
    ;;    repeat(prob) {
    ;;        numProb = numProb >> 1;
    ;;    }

    var res_dict = (0,0,0,0);
    ;;    var res_dict = new_dict();
    ;;    var value = begin_cell().end_cell().begin_parse();
    var distance = 0;
    ;; path~dump();
    while (~ null?(path)) {
        (var coords, path) = path.uncons();
        [int x,int y] = coords;
        distance = distance + 1;
        res_dict = setbitmask(res_dict,x * m + y);
        ;;   res_dict = res_dict | (1 <<  (x * m + y ) ); ;;mul is less exoensice than << ???????????????
        ;;res_dict~udict_set(10,(x << 5) + y, value);
    }

    tuple maze2 = empty_tuple();
    var i = 0;
    do {
        var str = at(maze, i);
        var j = 0;
        var str_gen = empty_tuple();
        ;;  var str_print = begin_cell();
        ;;   tuple str_gen = empty_tuple();
        do {
            ;;       str~dump();
            var item = at(str,j);
            ;;  (_,int flag) =     res_dict.udict_get?(10, (i << 5) + j);
            if (getbitmask(res_dict, i * m + j)) {
                str_gen~tpush("!"u);
                ;;      str_print~store_uint("!"u,8);
            } else {
                str_gen~tpush(item);
                ;;        str_print~store_uint(item,8);
            }
            j = j + 1;

            ;; res_dict = res_dict >> 1;
        } until (j == m);
        ;;  var sfd = str_print.end_cell().begin_parse();
        ;;    sfd~strdump();
        i  = i + 1;
        ;;      str_gen~dump();
        maze2~tpush(str_gen);
    } until (i == n);
    var res =  (prob / 1024,prob % 1024, distance + 1 , maze2);
;;      prob~dump();
;;      distance~dump();
;;       maze2~dump();
    return res;
;;      return ();
}
