#include "imports/stdlib.fc";

forall X -> tuple set_index_var (tuple t,X value,int pos) asm "SETINDEXVAR";

() recv_internal(slice in_msg_body) impure {

}




(int,int) look_start(int n,int m,tuple maze) inline {
    var i = 0;
    repeat (n) {
        var str = at(maze, i);  ;;.begin_parse();
        var j = 0;
        repeat (m) {
            var item = at(str, j);
            if (item == "S"u) {
                return (i, j);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return (0 , 0);
}

;; Tuple of slice's
(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {

    ;; return (-1,0,0, null());
    ;;        () solve() method_id {
    ;;            var n = 3;
    ;;            var m = 3;
    ;;            tuple maze = empty_tuple();
    ;;            tuple maze2 = empty_tuple();
    ;;            maze2~tpush("S"u);
    ;;            maze2~tpush("."u);
    ;;            maze2~tpush("."u);
    ;;            maze~tpush(maze2);
    ;;            tuple maze2 = empty_tuple();
    ;;            maze2~tpush("?"u);
    ;;            maze2~tpush("X"u);
    ;;            maze2~tpush("X"u);
    ;;            maze~tpush(maze2);
    ;;            tuple maze2 = empty_tuple();
    ;;           maze2~tpush("."u);
    ;;            maze2~tpush("."u);
    ;;            maze2~tpush("E"u);
    ;;            maze~tpush(maze2);
    ;;            maze~tpush("S..");
    ;;            maze~tpush(".??");
    ;;            maze~tpush("..E");
    (int startx,int starty) = look_start(n,m,maze);


    var state = new_dict();

    ;; var finished = 0;
    var current = cons ([ startx , starty , 0 , null() ], null());
    var answer = null();
    var countBest = 2000000;
    ;; current~dump();
    while (  ~ null? (current) ) {
        var next = null();
        while (~ null?(current)) {
            (var curpos, current) = uncons(current);

            [int _x, _ , _ , _ ] = curpos;
            var dx = ( _x ) ? -1 : 0 ;

            do {
                var str = at(maze, _x + dx);
                var dy = -1;
                repeat(3) {
                    if (dx | dy) {
                        ;;  (next, answer, state) = update(curpos, state, maze, dx, dy, n, m, next, answer, end);
                        [int x,int y,int count,tuple path] = curpos;
                        x = x + dx;
                        y = y + dy;
                        if (((y >= 0) & (x < n) & ( y < m))) {
                            var sym = at(str, y);
                            if (sym != "S"u) {
                                if (sym == "X"u) {
                                    count = count + 1000;
                                }
                                else {
                                    if (sym == "?"u) {
                                        count = count + 1;
                                    }
                                }
                                if (count < countBest) {
                                    var index = (x << 5) + y;
                                    (var state_cell, int f) = state.udict_get?(10, index);
                                    var test = true;
                                    if (f) {
                                        if (state_cell.preload_int(20) <= count) {
                                            test = false;
                                        }
                                    }
                                    if (test) {

                                        state = state.udict_set_builder(10, index, begin_cell().store_uint(count, 20));
                                        if (sym != "E"u) {
                                            ;;   if (count < countBest) {
                                            path = cons(index, path);
                                            next = cons([x, y, count, path], next);
                                            ;;   }
                                        } else {
                                            if (count < countBest) {
                                                answer = path;
                                                countBest = count;
                                            }
                                        }
                                    }
                                }
                            }
                        }

                    }

                    dy = dy + 1;
                }

                dx = dx + 1;
            } until (dx > 1);
        }
        current = next;
    }


    if (countBest == 2000000) {
        ;;          return ();
        return (-1,0,0, null());
    }
    var path = answer;
    var prob = countBest;

    var distance = 1;
    while (~ null?(path)) {
        (int index, path) = path.uncons();
        (int x,int y) = divmod(index,32);
        distance = distance + 1;
        var str = at(maze, x);
        str = set_index_var(str,"!"u,y);
        maze = set_index_var(maze,str,x);
    }

    (int d,int m) = divmod(prob,1000);
    return  (d,m, distance  , maze);
}
