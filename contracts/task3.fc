
#include "imports/stdlib.fc";

cell _migrate_one(cell storage) asm "1 CALL";


;; <<<<< Custom version-specific code begins
;; This section (everything between << and >> characters) will be fully substituted for each version.
;; This is an IMPORTANT part, and these exact lines with <<<<< and >>>>> must be present in your code for the testing system to work correctly.
;; All the code provided here serves as an example of the version-code, which your update code must be compatible with.
;; Refer to the "3-example" directory for more version examples.

;; from counter-v0.fc


;;cell migrate_one(cell old_storage) { ;; it's just a placeholder that is required for correct compilation
;;    return old_storage;
;;}

cell process_message(cell storage, int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
;;    slice cs = storage.begin_parse();
;;    int current_amount = cs.preload_uint(32);
    return begin_cell().end_cell();
}

;; Custom version-specific code ends >>>>>

;; OPT
cell wrap_storage(int version_id, cell storage) {
    ;; add additional data required for versioning in this cell
    return begin_cell()
    .store_uint(version_id,32)
    .store_ref(storage)
    ;;    .store_maybe_ref(new_code)
    .end_cell();
}

(cell, slice) load_dict_with_throw(slice s) asm """
  LDDICTQ
  400 THROWIFNOT
""";

() recv_internal(int msg_value, int balance, cell in_msg_full, slice in_msg_body) impure {
;;    if in_msg_body.slice_bits() < 32 {
;;        return();
;;    }
    var in_msg_body_backup = in_msg_body;
    var expected_version = in_msg_body~load_uint(32); ;; Skip the expected version
    if ( expected_version ==  0 ) {
        cell ds = get_data();
        set_data(wrap_storage(1,ds));
        return();
    }

    slice ds = get_data().begin_parse();
    var current_version = ds~load_uint(32);
    cell storage = ds.preload_ref();

;;    throw_if(400, expected_version < current_version);

    if (expected_version > current_version) {
        var new_code = in_msg_body~load_maybe_ref();
        throw_if ( 200, null?(new_code) );

        (cell dict, in_msg_body) = load_dict_with_throw(in_msg_body);

;;        var list = null();
        var cur =  current_version;
        var back = get_c3();
        do {
            (slice migration_code, int flag) = dict.udict_get?(32,cur);
            throw_unless(400,flag);
            cur = migration_code~load_uint(32);
            var code = migration_code~load_maybe_ref();

            if (~ null?(code)) {
                var c = bless(code.begin_parse());
                set_c3(c);
                storage = _migrate_one(storage);
;;                list = cons (code, list);
            }
        } until (cur == expected_version);
        set_c3(back);

        ;; reverse list
;;        var list2 = null();
;;        while (~ null?(list)) {
;;            (cell code,list) = uncons(list);
;;            list2 = cons (code, list2);
;;        }

        ;;execute migrations
;;        var back = get_c3();
;;        while ( ~ null?(list2)) {
;;            (cell code,list2) = uncons(list2);
;;            var c = bless(code.begin_parse());
;;            set_c3(c);
;;            storage = _migrate_one(storage);
;;        }
;;        set_c3(back);

        current_version = expected_version;

        set_code(new_code);
        set_data(wrap_storage(current_version, storage)); ;; -2 is just a random placeholder for the version
        commit();
        set_c3(bless(new_code.begin_parse()));
        recv_internal(msg_value, balance, in_msg_full, in_msg_body_backup);
    } else {
        in_msg_body~load_maybe_ref(); ;; Skip the expected code
        in_msg_body = in_msg_body.skip_dict(); ;; skip_dict(); ;; Skip dictionary
        cell payload = in_msg_body~load_ref();
        storage = process_message(storage, msg_value, balance, in_msg_full, payload.begin_parse());
        set_data(wrap_storage(current_version, storage)); ;; -2 is just a random placeholder for the version
        }
}


;; OPT
cell get_storage() {
    return get_data().begin_parse().skip_bits(32).preload_ref();
}


;; OPT
;; Return the current version of the smart contract
;; +3 TO COUNT
int version() method_id {
    return get_data().begin_parse().preload_uint(32);
}
