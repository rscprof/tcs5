#include "imports/stdlib.fc";
;;TODO sum -> storage (repeat)
;;Storage
;;admin_address: MsgAddressInt
;;users: (HashmapE 256 uint32)
const op::add_user = 0x368ddef3;
const op::remove_user = 0x278205c8;
const op::split_ton = 0x068530b3;
const op::transfer_notification = 0x7362d09c;

cell preload_dict_with_throw(slice s) asm """
  PLDDICTQ
  121 THROWIFNOT
""";

cell preload_dict_with_throw_122(slice s) asm """
  PLDDICTQ
  122 THROWIFNOT
""";

cell load_dict_with_check(slice ds) inline {
    if (slice_empty?(ds)) {
        return new_dict();
    } else {
        return ds.preload_dict();
    }
}


() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {

    if in_msg_body.slice_data_empty?() {
        return();
    }

    int op = in_msg_body~load_uint(32);





    if op == op::add_user {

        var in_msg_full_slice = in_msg_full.begin_parse().skip_bits(4);  ;;skip flags
        var source = in_msg_full_slice~load_msg_addr();

        var ds = begin_parse(get_data());
        var admin_addr = ds~load_msg_addr();
        throw_unless(120,(admin_addr).equal_slice_bits(source));

        ;;    add_user#368ddef3 query_id:uint64 address:MsgAddressInt share:uint32 = InternalMsgBody;
        in_msg_body~skip_bits(64);
    ;;    var address_with_prefix = ;
        (_ , int address) = (in_msg_body~load_msg_addr()).parse_std_addr(); ;;TODO optimise
     ;;   var share = ;

        cell dict = load_dict_with_check(ds);
        ;; new_dict();
;;        if (~ slice_empty?(ds)) {
;;            dict = ds.preload_dict();
;;        }
        ;;var dict = ds.preload_dict();

        ;; https://docs.ton.org/develop/func/stdlib/#load_msg_addr

        dict~udict_set_builder(256,address,begin_cell().store_uint(in_msg_body~load_uint(32),32));

        set_data(
            begin_cell().store_slice(admin_addr).store_dict(dict).end_cell()
        );

        return ();


    }
    ;; else {
        if op == op::remove_user {
            ;;            The contract should accept a message with op = 0x278205c8 and the following fields:
            ;;
            ;;            query_id: uint64
            ;;            address: MsgAddressInt
            ;;            The contract accepts the message, checks that it came from the admin, and if so, it removes the user from its storage. If the message did not come from the admin, the contract should throw error 120.
            ;;
            ;;            If the user is not in the storage, it should throw error 121.

            var in_msg_full_slice = in_msg_full.begin_parse().skip_bits(4);  ;;skip flags
            var source = in_msg_full_slice~load_msg_addr();

            var ds = begin_parse(get_data());
            var admin_addr = ds~load_msg_addr();
            throw_unless(120,admin_addr.equal_slice_bits(source));


            cell dict = preload_dict_with_throw(ds);
            ;;            cell dict = new_dict();
            ;;            if (~ slice_empty?(ds)) {
            ;;                dict = ds.preload_dict();
            ;;            }


            ;; var address_slice = address_with_prefix;

            in_msg_body~skip_bits(64);
            ;; int address_index = address_slice.preload_uint(address_slice.slice_bits());
            var address_with_prefix = in_msg_body~load_msg_addr();
            ;; https://docs.ton.org/develop/func/stdlib/#load_msg_addr
            (_ , int address) = address_with_prefix.parse_std_addr();
            throw_unless(121,dict~udict_delete?(256,address));

            set_data(
                begin_cell().store_slice(admin_addr).store_dict(dict).end_cell()
            );
            return ();

        }
        ;; else {
            if op == op::split_ton {
                ;;                Split (TON).
                ;;                The contract should accept a message with op = 0x068530b3 and the following fields:
                ;;
                ;;                query_id: uint64
                ;;                amount: Coins
                ;;                The contract accepts the message, distributes the TON to users according to their shares. Transactions must be sent with mode = 1 and no body.
                ;;
                ;;                If there are no users, error 122 must be thrown

                var ds = begin_parse(get_data());
                ds~load_msg_addr();
                ;;                cell dict = new_dict();
                ;;                if (~ slice_empty?(ds)) {
                ;;                    dict = ds.preload_dict();
                ;;                }
                cell dict = preload_dict_with_throw_122(ds);

                throw_if(122,dict.dict_empty?());


                ;;  in_msg_body~skip_bits(64);
            ;;    var amount = msg_value;
                int sum = 0;
                int key = -1;
                tuple list = null();
                ;;     int count = 0;
                do {
                    (key , slice cs, int f) = dict.udict_get_next?(256, key);
                    if f {
                        int value = cs.preload_uint(32);
                        sum = sum + value;
                        list = cons([key,value],list);
                        ;;              count = count + 1;
                    }
                } until (~ f);

                ;;   key = -1;
                ;;  repeat(count) {
                do {
                    (var res,list) = uncons(list);
                    [int key,int share] = res;

                    ;; (key , slice cs, _) = dict.udict_get_next?(256, key);
                    ;; if f
                    ;;     {
                    ;;     int share = cs.preload_uint(32);
                    var sending_amount = msg_value * share / sum;
;;                    var address = begin_cell()
;;                    ;;     .store_uint(2,2)
;;                    .store_uint(0x400,1 + 8 + 2) ;;Maybe Anycast
;;                    ;;     .store_uint(0,8) ;;Workchain id
;;                    .store_uint(key,256);
;;                    ;; .end_cell().begin_parse();

                    cell msg = begin_cell()
               ;;     .store_uint(0x18, 6) ;; flags
               ;;     .store_builder(address) ;; destination address
                    .store_uint(0xc400,1 + 8 + 2 + 6) ;;Maybe Anycast
                    ;;     .store_uint(0,8) ;;Workchain id
                    .store_uint(key,256)
                    .store_coins(sending_amount)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)
                    ;;.store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
                    ;;  .store_slice("Hello from FunC!") ;; comment
                    .end_cell();

                    send_raw_message(msg, 1);

                    ;;   }
                } until (null?(list));

                return();
            }
            ;; else {
                ;;     if op == op::transfer_notification {
                ;;                    The contract should receive a message with op = 0x7362d09c and the following fields:
                ;;
                ;;                    query_id: uint64
                ;;                    amount: Coins
                ;;                    If there are no users, then error 122 must be thrown.
                ;;
                ;;                    The contract should send out to all users according to their amount of tokens. You should send messages to the address of your token jack jetton_address according to TEP-0074.
                ;;
                ;;                    Message Value: 0.02 TON
                ;;                    Response address must be equal to the recipient address
                ;;                    Forward_amount = 1 nanoTON
                ;;                    Without custom_payload / without forward_payload.
                ;;                    Note: transfer_notification in this task does not conform to the TEP-0074 standard. This is done to simplify the task.
                var in_msg_full_slice = in_msg_full.begin_parse().skip_bits(4);  ;;skip flags
                var source = in_msg_full_slice~load_msg_addr();


                var ds = begin_parse(get_data());
                ds~load_msg_addr();
                cell dict = preload_dict_with_throw_122(ds);
                ;;                    cell dict = new_dict();
                ;;                    if (~ slice_empty?(ds)) {
                ;;                        dict = ds.preload_dict();
                ;;                    }
                ;;
                ;;
                throw_if(122,dict.dict_empty?());

                in_msg_body~skip_bits(64);
                var amount = in_msg_body~load_coins();
                int sum = 0;
                int key = -1;
                ;;    int count = 0;
                tuple list = null();
                do {
                    (key , slice cs, int f) = dict.udict_get_next?(256, key);
                    if f {
                        int value = cs.preload_uint(32);
                        sum = sum + value;
                        ;;          count = count + 1;
                        list = cons([key,value],list);
                    }
                } until (~ f);


                var msg_start = begin_cell()
                .store_uint(0x18, 6) ;; flags -- TEST
                .store_slice(source) ;; destination address
                .store_uint(4,4)
                .store_uint(0x1312D00,32)
                .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1); ;; default message headers (see sending messages page)  -- TEST

                do {
                    (var res,list) = uncons(list);
                    [int key,int share] = res;
                    ;;     (key , slice cs, _ ) = dict.udict_get_next?(256, key);
                    ;; if f
                    ;;     {
                    ;;         int share = cs.preload_uint(32);
                    var sending_amount = amount * share / sum;
                    ;; sending_amount~dump();
                    ;; key -> address
                    ;; addr_std$10 anycast:(Maybe Anycast)
                    ;; workchain_id:int8 address:bits256  = MsgAddressInt;
                    var address = begin_cell()
                    ;;  .store_uint(2,2)
                    ;;  .store_uint(0,1) ;;Maybe Anycast
                    .store_uint(0x400,8 + 1 + 2) ;;Workchain id
                    .store_uint(key,256);
                    ;;.end_cell().begin_parse();
                    ;;                            transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
                    ;;                            response_destination:MsgAddress custom_payload:(Maybe ^Cell)
                    ;;                            forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
                    ;;                            = InternalMsgBody;

                    ;;address~dump();

                    var body = begin_cell()
                    .store_uint(0x0f8a7ea50000000000000000,32 + 64)
                  ;;  .store_uint(0,64) ;;query id
                    .store_coins(sending_amount)
                    .store_builder(address)  ;; destination TEST (perhaps wallet)
                    .store_builder(address)  ;; response destination
                    .store_uint(0x202,1 + 4 + 8 + 1)   ;;Maybe cell
                  ;;  .store_uint(1,4)
                  ;;  .store_uint(1,8)
                    ;; .store_coins(1) ;;in nanotons (10^-9 ton) we need gram
                  ;;  .store_uint(0,1)
                    ;; .store_slice(begin_cell().end_cell().begin_parse())
                    ;;.store_uint(0, 32) ;; zero opcode - means simple transfer message with comment
                    ;;  .store_slice("Hello from FunC!") ;; comment
                    .end_cell();


                    var msg = begin_cell()
                            .store_builder(msg_start)
;;                    .store_uint(0x18, 6) ;; flags -- TEST
;;                    .store_slice(source) ;; destination address
;;                     .store_uint(4,4)
;;                     .store_uint(0x1312D00,32)
;;                    .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1) ;; default message headers (see sending messages page)  -- TEST
;;                    ;; .store_uint(1,1)
                    .store_ref(body)
                    .end_cell();


                    ;;msg~dump();
                    send_raw_message(msg, 0);

                    ;;   }
                } until(null?(list));


                ;;   }
          ;;  }
    ;;    }
 ;;   }


    ;;    remove_user#278205c8 query_id:uint64 address:MsgAddressInt = InternalMsgBody;
    ;;    split_ton#068530b3 query_id:uint64 amount:Coins = InternalMsgBody;
    ;;    transfer_notification#701c09a6 query_id:uint64 amount:Coins = InternalMsgBody;

}


;;get_users: returns a dictionary with 267 bit keys (user addresses) and the value is uint32, which means user share.
cell  get_users() method_id {
    var ds = begin_parse(get_data());
    ds~load_msg_addr();
    cell dict = new_dict();
    if (~ slice_empty?(ds)) {
        dict = ds.preload_dict();
    }

    return dict;
}

;;    (_, int address) = user_address.parse_std_addr();
;;    var ds = begin_parse(get_data());
;;    ds~load_msg_addr();
;;    (slice res,_) = ds.preload_dict().udict_get?(256,address);
;;    return res.preload_uint(32);
int get_user_share_asm(slice user_address) asm """
  REWRITESTDADDR
  NIP
  c4 PUSH
  // addr c4
  CTOS
// addr slice
  LDMSGADDR
// addr addr' slice
  NIP
// addr slice
  PLDDICT
// addr dict
  8 PUSHPOW2
// addr dict 256
  DICTUGET
// x flag
  DROP
  // x
  32 PLDU
""";


;;get_user_share(slice user_address): calculates and returns the user's share.
;;get_execution_time: returns the time in seconds when the contract should be unlocked to transfer the TONs to the beneficiary address.
int  get_user_share(slice user_address) method_id {
    return get_user_share_asm(user_address);
    ;;        (_, int address) = user_address.parse_std_addr();
    ;;    var ds = begin_parse(get_data());
    ;;    ds~load_msg_addr();
    ;;    (slice res,_) = ds.preload_dict().udict_get?(256,address);
    ;;    return res.preload_uint(32);
}
