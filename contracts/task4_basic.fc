#include "imports/stdlib.fc";

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {

}

(tuple, [(int,int),int,tuple]) update(tuple next, [(int,int),int,tuple] answer, [(int,int),int,tuple] newpos, (int,int) end, int flag)
{

    [_,var countBest,_] = answer;
    if (flag) {
        ;;var f = first(newpos);
        [var f,var count,_] = newpos;
        (var x, var y) = f;
        (var endx, var endy) = end;

        if ((x == endx) & (y == endy)) {
            if (null? (answer)) {
                answer = newpos;
            } else {
                if (count < countBest) {
                    answer = newpos;
                }
            }
        } else {
            next = cons( newpos,next);
        }
    }
    return (next, answer);
}

;; (start,0,())
([(int,int),int,tuple],cell,int) test ([(int,int),int,tuple] curpos,cell state,tuple maze,int dx,int dy,int n,int m)
{
    [var pos,var count,var path] = curpos;
;;    var pos = first(curpos);
;;    var count = second(curpos);
;;    var path = third(curpos);
;;    ;;    var count, var path) = curpos;
    (var x, var y) = pos;
    x = x + dx;
    y = y + dy;
    if (x < 0) { return (null(),state,0); }
    if (y < 0) { return (null(),state,0); }
    if (x >= n) { return (null(),state,0); }
    if (y >= m) { return (null(),state,0); }
    var sym = at(at(maze,x),y);
    if (sym == "S"u) { return (null(),state,0); }
    if (sym == "X"u) { return (null(),state,0); }
    (var state_cell, int f) = state.udict_get?(10,(x << 5) + y);
    if (sym == "?"u) { count = count + 1; }
    if (f) {
        var countInState = state_cell.preload_int(10);
        if (countInState < count) {
            { return (null(),state,0); }
        }
    }
    state = state.udict_set(10,(x << 5) + y , begin_cell().store_uint(count,10).end_cell().begin_parse());
    var newpos = (x,y);
    path = cons([x,y],path);
    return ([newpos,count,path], state,-1);
}

(int, int, int, tuple) solve(int n, int m, tuple maze) method_id {
    var i = 0;
    var start = (0,0);
    var end = (0,0);
    repeat(n) {
        var str = at(maze, i);
        var j = 0;
        repeat(m) {
            var item = at(str,j);
            j = j + 1;
            if (item == "S"u) {
                start = (i , j);
            }
            if (item == "E"u) {
                end = (i , j);
            }
        }
        i  = i + 1;
    }

    var state = new_dict();

    var failed = 0;
    var finished = 0;
    var current = cons ([start,0,()], null());
    var answer = null();
    while (  ~ finished ) {
        var next = null();
        (var curpos, current) = uncons(current);
        (var newpos, state, var flag) = test (curpos,state,maze,-1,-1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,-1,0,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,-1,1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,0 ,-1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,0,1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,1,-1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,1,0,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        (newpos,state,flag) = test (curpos,state,maze,1,1,n, m);
        (next,answer) = update(next,answer,newpos, end, flag);
        if null? (next) {
            finished = true;
        }
        current = next;
    }

    if (null?(answer)) {
        return (-1,0,0, null());
    }
    ;; [(int,int),int,tuple] answer
    [_,var prob,var path] = answer;
    var numProb = 100;
    repeat(prob) {
            numProb = numProb >> 1;
    }

    var res_dict = new_dict();
    var value = begin_cell().end_cell().begin_parse();
    var distance = 0;
    while (~ null?(path)) {
        (var coords, path) = path.uncons();
        [int x,int y] = coords;
        distance = distance + 1;
        res_dict~udict_set(10,(x << 5) + y, value);
    }

    tuple maze2 = empty_tuple();
    var i = 0;
    repeat(n) {
        var str = at(maze, i);
        var j = 0;
        tuple str_gen = empty_tuple();
        repeat(m) {
            var item = at(str,j);
            (_,int flag) = res_dict.udict_get?(10, (i << 5) + j);
            j = j + 1;
            if (flag) {
                str_gen~tpush("!"u);
            } else {
                str_gen~tpush(item);
            }
        }
        i  = i + 1;
        maze2~tpush(str_gen);
    }


    return (-1,numProb,distance + 1, maze2);
}
